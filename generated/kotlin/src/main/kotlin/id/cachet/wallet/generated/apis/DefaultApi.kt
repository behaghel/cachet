/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package id.cachet.wallet.generated.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import id.cachet.wallet.generated.models.CredentialRequest
import id.cachet.wallet.generated.models.CredentialResponse
import id.cachet.wallet.generated.models.Error
import id.cachet.wallet.generated.models.TokenRequest
import id.cachet.wallet.generated.models.TokenResponse
import id.cachet.wallet.generated.models.VeriffSession

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import id.cachet.wallet.generated.infrastructure.ApiClient
import id.cachet.wallet.generated.infrastructure.ApiResponse
import id.cachet.wallet.generated.infrastructure.ClientException
import id.cachet.wallet.generated.infrastructure.ClientError
import id.cachet.wallet.generated.infrastructure.ServerException
import id.cachet.wallet.generated.infrastructure.ServerError
import id.cachet.wallet.generated.infrastructure.MultiValueMap
import id.cachet.wallet.generated.infrastructure.PartConfig
import id.cachet.wallet.generated.infrastructure.RequestConfig
import id.cachet.wallet.generated.infrastructure.RequestMethod
import id.cachet.wallet.generated.infrastructure.ResponseType
import id.cachet.wallet.generated.infrastructure.Success
import id.cachet.wallet.generated.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8090")
        }
    }

    /**
     * POST /webhooks/veriff
     * Veriff webhook endpoint
     * Receives verification status updates from Veriff
     * @param veriffSession 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun handleVeriffWebhook(veriffSession: VeriffSession) : Unit {
        val localVarResponse = handleVeriffWebhookWithHttpInfo(veriffSession = veriffSession)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /webhooks/veriff
     * Veriff webhook endpoint
     * Receives verification status updates from Veriff
     * @param veriffSession 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun handleVeriffWebhookWithHttpInfo(veriffSession: VeriffSession) : ApiResponse<Unit?> {
        val localVariableConfig = handleVeriffWebhookRequestConfig(veriffSession = veriffSession)

        return request<VeriffSession, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation handleVeriffWebhook
     *
     * @param veriffSession 
     * @return RequestConfig
     */
    fun handleVeriffWebhookRequestConfig(veriffSession: VeriffSession) : RequestConfig<VeriffSession> {
        val localVariableBody = veriffSession
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/webhooks/veriff",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /healthz
     * Health check endpoint
     * Returns service health status
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun healthCheck() : kotlin.String {
        val localVarResponse = healthCheckWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /healthz
     * Health check endpoint
     * Returns service health status
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun healthCheckWithHttpInfo() : ApiResponse<kotlin.String?> {
        val localVariableConfig = healthCheckRequestConfig()

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation healthCheck
     *
     * @return RequestConfig
     */
    fun healthCheckRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/healthz",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /credential
     * Request verifiable credential
     * Issue a verifiable credential using OpenID4VCI protocol
     * @param credentialRequest 
     * @return CredentialResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestCredential(credentialRequest: CredentialRequest) : CredentialResponse {
        val localVarResponse = requestCredentialWithHttpInfo(credentialRequest = credentialRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredentialResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /credential
     * Request verifiable credential
     * Issue a verifiable credential using OpenID4VCI protocol
     * @param credentialRequest 
     * @return ApiResponse<CredentialResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestCredentialWithHttpInfo(credentialRequest: CredentialRequest) : ApiResponse<CredentialResponse?> {
        val localVariableConfig = requestCredentialRequestConfig(credentialRequest = credentialRequest)

        return request<CredentialRequest, CredentialResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestCredential
     *
     * @param credentialRequest 
     * @return RequestConfig
     */
    fun requestCredentialRequestConfig(credentialRequest: CredentialRequest) : RequestConfig<CredentialRequest> {
        val localVariableBody = credentialRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/credential",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /oauth/token
     * Request OAuth2 access token
     * OAuth2 client credentials flow for obtaining access tokens
     * @param tokenRequest 
     * @return TokenResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestToken(tokenRequest: TokenRequest) : TokenResponse {
        val localVarResponse = requestTokenWithHttpInfo(tokenRequest = tokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /oauth/token
     * Request OAuth2 access token
     * OAuth2 client credentials flow for obtaining access tokens
     * @param tokenRequest 
     * @return ApiResponse<TokenResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestTokenWithHttpInfo(tokenRequest: TokenRequest) : ApiResponse<TokenResponse?> {
        val localVariableConfig = requestTokenRequestConfig(tokenRequest = tokenRequest)

        return request<TokenRequest, TokenResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestToken
     *
     * @param tokenRequest 
     * @return RequestConfig
     */
    fun requestTokenRequestConfig(tokenRequest: TokenRequest) : RequestConfig<TokenRequest> {
        val localVariableBody = tokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/oauth/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
